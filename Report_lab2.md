#Лабороторная №2

###Выполнил
Кочетков Никита Олегович, M4139

###Реализовано
`BWT + MTF + RLE + адаптивное арифметическое кодирование`

##Алгоритм кодирования
###Пред подготовка
Перед тем как мы будем обрабатывать поданные нам jpeg, то мы удалим первый байт у них, так как он у всех джепегов одинаковый 
и равен 255 (FF). При декодировании вернём.


###Преобразования Барроуза-Уиллера
Перед тем как закодировать исходный файл, мы сначала преобразуем данные для лучшего сжатия.  
Первым алгоритмом преобразования будет: **алгоритм преобразования Барроуза-Уиллера**  
Рассмотрим все циклические сдвиги этого блока и запишем в массив 
после чего отсортируем в лексикографическом порядке, найдём номер исходного блока в этом массиве и запомним его. Возьмём в виде преобразованной последовательности последний столбец в отсортированном массиве. 
Так для каждого блока у нас будет новый преобразованный блок и индекс.

Запишем в начало выходного файл номер строки, которая была взята bwt, для будущего декодирования и потратим на это 2 байта.
###MTF
После предыдущего преобразования преобразуем теперь данные методом стопки книг, так как после предыдущего преобразования у данных появляется больше одинаковых символов подряд, поэтому этот метод будет хорошо сжимать.

Возьмём упорядоченный алфавит. Теперь для каждого элемента последовательности полученной в предыдущем шаге мы сделаем поочереди следующее: 
найдём этот элемент в алфавите и выпишем его индекс, символ из алфавита перемещается в голову алфавита (остальные символы левее него делают сдвиг направо). 
В результате у нас будет список индексов с которыми мы теперь будем дальше работать. 


###RLE
После шага с MTF у нас есть последовательность бит. Применим умный RLE.

Умность данного подхода заключается в том, чтобы мы будем кодировать так. Если символ одиночный, то мы просто его 
запишем. Если символов уже несколько, то запишем два подряд символа и число подряд идущих. Если выделять по 2 байта на это число, то получается большой прирост ненужных байтов в итогом файле. 
Для этого мы будем писать по одному байте, а последовательности длиной > 256 мы закодируем 256 и пойдём счётчиком с 1 снова

###Адаптивное кодирование
Применим теперь к получившийся последовательности бит адапативное арифметическое кодирование.

Получаем конечный сжатый файл

##Алгоритм декодирования
###Адаптивное кодирование
Аналогично тому, как мы закодировали, применим обратный алгоритм для получения изначальной последовательности бит.

###RLE
Теперь мы будем вытаскивать обратно изначальную цепочку подряд идущих бит. Мы читаем бит текущий и следующий. Если они разные, то записываем текущий. Если же разные, то 
мы начинаем считывать 2 бита и ещё 1 бит после. Таким образом мы узнаём сколько надо добавить символов. Не забываем про магию, что бит всё таки -128..127 и приводим к нормальному виду (для числа подряд идущих). 

После этого получаем и=последовательность бит, которую отдаём на обратный MTF

###MTF
После предыдущего шага у нас имеет последовательно индексов. Сделаем так же как и с прямым преобразованием. Только по индексу мы будем возвращаем соответствующий символ алфавита.

###Преобразования Барроуза-Уиллера
Разобьём последовательность на блоки по 250. Теперь восстановим изначальный блок

Повторим N раз в зависимости от размера блока: начальная строка блока записывается в первый столбец массива блоков, после чего массив сортируется. В результате имеем такую же матрицу, как при кодировании. Возьмём блок по индексу, который лежал соответственно в начале файла.

Таким образом мы получим изначальную последовательность, которую запишем в выходящий файл.

###Поспроцессинг
Так как при кодировании мы забрали зи начала jpg 1 бит, то мы его возвращаем в начало записываемого файла. И таким образом получаем исходный jpg.

##Результаты

###QF=30

| Файл              | Итоговое сжатие 
|:----------------- |:------ 
| sails30.jpg       | 45296                         
| arctichare30.jpg  | 11484                         
| monarch30.jpg     | 28305                         
| tulips30.jpg      | 37900                         
| pool30.jpg        | 6226                         
| cat30.jpg         | 35903                          
| frymire30.jpg     | 195040                         
| lena30.jpg        | 17514                           
| baboon30.jpg      | 36065                         
| girl30.jpg        | 23663                          
| watch30.jpg       | 44634                          
| serrano30.jpg     | 57578                          
| peppers30.jpg     | 18687                          
| fruits30.jpg      | 17564                          
| airplane30.jpg    | 18908                          


####Суммарное значение всех сжатых файлов для QF=30
Суммарное значение размера всех сжатых файлов в байтах: **594 767**

###QF=80

| Файл              | Итоговое сжатие
|:----------------- |:------ 
| cat80.jpg         | 82060
| frymire80.jpg     | 433969
| baboon80.jpg      | 88604
| girl80.jpg        | 59746
| watch80.jpg       | 100164
| serrano80.jpg     | 137217
| lena80.jpg        | 43912
| sails80.jpg       | 106012
| arctichare80.jpg  | 26306
| tulips80.jpg      | 85946
| pool80.jpg        | 13856
| monarch80.jpg     | 64172
| fruits80.jpg      | 45392
| airplane80.jpg    | 44136
| peppers80.jpg     | 47949


####Суммарное значение всех сжатых файлов для QF=80
Суммарное значение размера всех сжатых файлов в байтах: **1 379 441**