package com.kochetkov.archiver.solve

import java.io.*
import kotlin.Throws
import kotlin.jvm.JvmStatic
import java.lang.IllegalArgumentException

/**
 * Decompression application using static arithmetic coding.
 *
 * Usage: java ArithmeticDecompress InputFile OutputFile
 *
 * This decompresses files generated by the "ArithmeticCompress" application.
 */
object ArithmeticDecompress {
    @Throws(IOException::class)
    @JvmStatic
    fun main(args: Array<String>) {
        // Handle command line arguments
        if (args.size != 2) {
            System.err.println("Usage: java ArithmeticDecompress InputFile OutputFile")
            System.exit(1)
            return
        }
        val inputFile = File(args[0])
        val outputFile = File(args[1])
        BitInputStream(BufferedInputStream(FileInputStream(inputFile))).use { `in` ->
            BufferedOutputStream(FileOutputStream(outputFile)).use { out ->
                val freqs: FrequencyTable = readFrequencies(`in`)
                decompress(freqs, `in`, out)
            }
        }
    }

    // To allow unit testing, this method is package-private instead of private.
    @Throws(IOException::class)
    fun readFrequencies(`in`: BitInputStream): FrequencyTable {
        val freqs = IntArray(257)
        for (i in 0..255) freqs[i] = readInt(`in`, 32)
        freqs[256] = 1 // EOF symbol
        return SimpleFrequencyTable(freqs)
    }

    // To allow unit testing, this method is package-private instead of private.
    @Throws(IOException::class)
    fun decompress(freqs: FrequencyTable?, `in`: BitInputStream?, out: OutputStream) {
        val dec = ArithmeticDecoder(32, `in`!!)
        while (true) {
            val symbol: Int = dec.read(freqs)
            if (symbol == 256) // EOF symbol
                break
            out.write(symbol)
        }
    }

    // Reads an unsigned integer of the given bit width from the given stream.
    @Throws(IOException::class)
    private fun readInt(`in`: BitInputStream, numBits: Int): Int {
        require(!(numBits < 0 || numBits > 32))
        var result = 0
        for (i in 0 until numBits) result = result shl 1 or `in`.readNoEof() // Big endian
        return result
    }
}